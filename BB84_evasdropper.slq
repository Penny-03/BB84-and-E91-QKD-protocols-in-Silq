// BB84 QKD Protocol 

// Constants definition
n := 200:!N; // around a quarter of tatal bits
total_bits:=1000 :!N;
err_threshold:=2:!N; 
 
// Generates random data bits
def random_bits(total_bits:!N):! B^total_bits {
    a:= vector(total_bits, 0:!B); 
    for i in [0..total_bits){
      a[i]=measure(H(false));
    }
    return a;
}

// Returns 0 with probability p, and 1 with probability (1 - p)
def simulate_probability(p: !R): !B {
    theta := 2.0 * acos(sqrt(p));     
    q := rotY(theta, 0:B);            
    return measure(q);            
}


def random_index(max:!N): !N {
    // Special case when max is 1
    if max == 1 { return 0:!N; }
    
    // Determine how many bits we need to represent max-1
    bits_needed := 0:!N;
    temp := max-1;
    while temp > 0 {
        temp = temp div 2;
        bits_needed += 1;
    }
    
    // Generate enough random bits and compute the number using powers of 2
    result := 0:!N;
    power_of_two := 1:!N;  // Tracks 2^i without bit shifting
    for i in [0..bits_needed) {
        if measure(H(false)) {
            result += power_of_two;
        }
        power_of_two *= 2;
    }
    
    // Ensure it's within range
    return result % max;
}

// Function to randomly select indices for check bits
def select_check_indices(matching_length:!N, n:!N): !B^matching_length {
    // We'll use quantum randomness to select check bits
    is_check_bit := vector(matching_length, false:!B);
    
    // We need to select exactly n bits for checking
    count := 0:!N;
    while count < n {
        // Generate a proper random index
        selected_index := random_index(matching_length);
        
        // If not already selected as check bit
        if !is_check_bit[selected_index] {
            is_check_bit[selected_index] = true;
            count += 1;
        }
    }
    return is_check_bit;
}

def eavesdrop(qubit:B, eve_basis:!B): B {
    // Eve measures the qubit in her randomly chosen basis
    if eve_basis { // Measure in X basis
        qubit:= H(qubit);
    } 
    result := measure(qubit);
    
    // Eve prepares a new qubit in the state she measured
    // (This is the "intercept-resend" attack)
    new_qubit := 0:B;
    if result {
        new_qubit:= X(new_qubit);
    }
    if eve_basis { // Prepare in X basis if that's what she used
        new_qubit:= H(new_qubit);
    }
    
    return new_qubit;
}

// Main BB84 protocol function
def BB84_protocol(p:!R) : !R^3 { // !B[]

    eve_present:= true:!B; // Set to true to simulate Eve
    // Eve also generates random bases for her measurements
    if eve_present {
        eve_bases := random_bits(total_bits);
    } else {
        eve_bases := vector(total_bits, 0:!B); // No Eve, no bases
    }


    // Step 1: Alice generates random data bits
    // Step 2: Alice generates random basis choices and encodes qubits
    // Step 3: Alice sends qubits to Bob 
    // Step 4: Bob generates random bases and measures

    alice_bases := random_bits(total_bits);
    bob_bases := random_bits(total_bits);

    alice_string_a := random_bits(total_bits); //(a)
        
     //encode(alice_string_a, alice_bases);
    bob_results := vector(total_bits, 0:!B); //  measure_qubits(qubits_sent, bob_bases); //(a1)

   
    for i in [0..total_bits) {
        qubits_sent := 0:B; // Initialize qubits_sent for each bit
        //Encoding a given the bitsring b 
        //If the base is Z (b is 0), a is encoded as |0⟩ if it was a 0 or as |1⟩ if it was 1.
        // If the base is X (b is 1), a is encoded as |+⟩ if it was a 0 or as |-⟩ if it was 1.
        if alice_string_a[i] {
            qubits_sent := X(qubits_sent);
        }
        if alice_bases[i] { // if basis choice is 1, use Hadamard basis (X)
            qubits_sent := H(qubits_sent);
        }

         // Eve's interception (if present)
        if eve_present && !simulate_probability(p){
            qubits_sent := eavesdrop(qubits_sent, eve_bases[i]);

        }


        //Bob recives and measures the qubits given a random bitstring b1 and he gets a1
        // If b1=0 use Z base
        // If b=1 use X base
        if bob_bases[i] { // measure in X basis
            qubits_sent:=H(qubits_sent);
        }
        bob_results[i] = measure(qubits_sent);// measure in Z basis
    }

    // Step 5: Alice announces her basis choices
    
    // Step 6: keep only bits where bases matched(where b=b1 they keep the bits in a and a1)

    matching_basis_alice := array(0, 0:!B);
    matching_basis_bob := array(0, 0:!B);
    
    for i in [0..total_bits) {
        if alice_bases[i] == bob_bases[i] {
            matching_basis_alice~= (alice_string_a[i],);
            matching_basis_bob~= (bob_results[i],);  
        }
    }

    // Step 7: Select check bits 
    is_check_bit := select_check_indices(matching_basis_alice.length, n);
    
    // Separate into check bits and key bits
    
    // Now allocate arrays
    check_bits_alice := array(0, 0:!B);
    check_bits_bob := array(0, 0:!B);
    final_key_alice := array(0, 0:!B);
    final_key_bob := array(0, 0:!B);
    
    
    for i in [0..matching_basis_alice.length) {
        if is_check_bit[i] {
            check_bits_alice~= (matching_basis_alice[i],);
            check_bits_bob ~= (matching_basis_bob[i],);
        } else {
            final_key_alice~= (matching_basis_alice[i],);
            final_key_bob ~= (matching_basis_bob[i],);
            
        }
    }
    
    // Step 8: Compare check bits
    error_count := 0:!N;
    for i in [0..check_bits_alice.length) {
        if check_bits_alice[i] != check_bits_bob[i] {
            error_count += 1;
        }
    }
    
    
    // If error rate is too high, abort
    //if error_count > err_threshold { 
        //print("!PROTOCOL ABORTED! --- Error rate too high");
        //return vector(1, 1:!B); 
       // print(1);
       // return (error_count:!R, check_count:!R, length_matching:!R); // Return QBER as float
   // }
    
    // If everything is OK, return the final key
    //return final_key_bob;
    return (error_count:!R, check_bits_alice.length :!R, matching_basis_alice.length:!R); // QBER, n, N
 

}


def main(){
  //key:= BB84_protocol(0.0): !B[];
 //print(key)
    p_eve := 0.0:!R;
    (qber, n, N):= BB84_protocol(p_eve): !R^3;
    print(qber);
    print(n);
    print(N);

}
